/**
 * Service Offline-First unifi√© avec UI Optimiste
 *
 * Architecture:
 * 1. √âcriture locale imm√©diate (IndexedDB) - UI r√©active instantan√©ment
 * 2. Ajout √† l'outbox queue avec idempotency key
 * 3. Synchronisation en arri√®re-plan avec retry intelligent
 * 4. R√©solution de conflits automatique (Last-Write-Wins)
 * 5. Background Sync API pour sync m√™me quand app ferm√©e
 */

import { db, OutboxOperation } from '../db'
import {
  patientsService,
  encountersService,
  conditionsService,
  medicationsService,
  proceduresService
} from './api'
import { v4 as uuidv4 } from 'uuid'

// ===========================================================================
// TYPES
// ===========================================================================

export interface OfflineWriteResult<T = any> {
  success: boolean
  localId: string
  data: T
  isOffline: boolean
  willSyncLater: boolean
}

export interface SyncResult {
  success: boolean
  synced: number
  failed: number
  conflicts: number
  errors: string[]
}

export interface ConflictResolution {
  strategy: 'last-write-wins' | 'first-write-wins' | 'manual'
  resolvedData?: any
}

// ===========================================================================
// D√âTECTION DE CONNECTIVIT√â AM√âLIOR√âE
// ===========================================================================

class ConnectivityMonitor {
  private isOnlineState = navigator.onLine
  private listeners: Set<(isOnline: boolean) => void> = new Set()
  private checkInterval: NodeJS.Timeout | null = null

  constructor() {
    // Listeners natifs
    window.addEventListener('online', this.handleOnline)
    window.addEventListener('offline', this.handleOffline)

    // V√©rification p√©riodique (toutes les 30s)
    this.startPeriodicCheck()
  }

  private startPeriodicCheck() {
    this.checkInterval = setInterval(() => {
      this.checkConnectivity()
    }, 30000)
  }

  private handleOnline = () => {
    if (!this.isOnlineState) {
      this.isOnlineState = true
      this.notifyListeners(true)
      console.log('üì° Connexion r√©tablie')
    }
  }

  private handleOffline = () => {
    if (this.isOnlineState) {
      this.isOnlineState = false
      this.notifyListeners(false)
      console.log('üì° Connexion perdue - Mode offline activ√©')
    }
  }

  private notifyListeners(isOnline: boolean) {
    this.listeners.forEach(listener => listener(isOnline))
  }

  isOnline(): boolean {
    return this.isOnlineState
  }

  addListener(listener: (isOnline: boolean) => void): () => void {
    this.listeners.add(listener)
    // Appeler imm√©diatement avec l'√©tat actuel
    listener(this.isOnlineState)

    return () => {
      this.listeners.delete(listener)
    }
  }

  async checkConnectivity(): Promise<boolean> {
    if (!navigator.onLine) {
      if (this.isOnlineState) {
        this.handleOffline()
      }
      return false
    }

    try {
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 3000)

      const response = await fetch('/api/health', {
        method: 'HEAD',
        signal: controller.signal,
        cache: 'no-cache',
      })

      clearTimeout(timeoutId)

      const isOnline = response.ok
      if (isOnline && !this.isOnlineState) {
        this.handleOnline()
      } else if (!isOnline && this.isOnlineState) {
        this.handleOffline()
      }

      return isOnline
    } catch {
      if (this.isOnlineState) {
        this.handleOffline()
      }
      return false
    }
  }

  destroy() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval)
    }
    window.removeEventListener('online', this.handleOnline)
    window.removeEventListener('offline', this.handleOffline)
  }
}

export const connectivityMonitor = new ConnectivityMonitor()

// ===========================================================================
// EXPONENTIAL BACKOFF
// ===========================================================================

class ExponentialBackoff {
  private static readonly BASE_DELAY = 1000 // 1 seconde
  private static readonly MAX_DELAY = 300000 // 5 minutes
  private static readonly JITTER_FACTOR = 0.1

  /**
   * Calcule le d√©lai avant la prochaine tentative
   * @param attempt Num√©ro de tentative (0-indexed)
   * @returns D√©lai en millisecondes
   */
  static calculateDelay(attempt: number): number {
    // Formule: min(MAX_DELAY, BASE_DELAY * 2^attempt) + jitter
    const exponentialDelay = Math.min(
      this.MAX_DELAY,
      this.BASE_DELAY * Math.pow(2, attempt)
    )

    // Ajouter un jitter al√©atoire (+/- 10%)
    const jitter = exponentialDelay * this.JITTER_FACTOR * (Math.random() * 2 - 1)

    return Math.floor(exponentialDelay + jitter)
  }

  /**
   * D√©termine si on doit r√©essayer cette op√©ration
   */
  static shouldRetry(attempts: number, maxAttempts: number = 10): boolean {
    return attempts < maxAttempts
  }

  /**
   * Attend le d√©lai calcul√©
   */
  static async wait(attempt: number): Promise<void> {
    const delay = this.calculateDelay(attempt)
    console.log(`‚è±Ô∏è  Retry in ${Math.round(delay / 1000)}s (attempt ${attempt + 1})`)
    return new Promise(resolve => setTimeout(resolve, delay))
  }
}

// ===========================================================================
// R√âSOLUTION DE CONFLITS
// ===========================================================================

class ConflictResolver {
  /**
   * R√©sout un conflit avec strat√©gie Last-Write-Wins
   * Compare les timestamps et garde la version la plus r√©cente
   */
  static resolveLastWriteWins(
    localData: any,
    serverData: any
  ): ConflictResolution {
    const localTimestamp = new Date(localData.updated_at || localData.created_at || 0).getTime()
    const serverTimestamp = new Date(serverData.updated_at || serverData.created_at || 0).getTime()

    if (localTimestamp >= serverTimestamp) {
      console.log('‚úÖ Conflit r√©solu: version locale retenue (plus r√©cente)')
      return {
        strategy: 'last-write-wins',
        resolvedData: localData,
      }
    } else {
      console.log('‚úÖ Conflit r√©solu: version serveur retenue (plus r√©cente)')
      return {
        strategy: 'last-write-wins',
        resolvedData: serverData,
      }
    }
  }

  /**
   * R√©sout un conflit avec strat√©gie First-Write-Wins
   * Garde toujours la version serveur
   */
  static resolveFirstWriteWins(serverData: any): ConflictResolution {
    console.log('‚úÖ Conflit r√©solu: version serveur retenue (first-write-wins)')
    return {
      strategy: 'first-write-wins',
      resolvedData: serverData,
    }
  }
}

// ===========================================================================
// SERVICE DE SYNCHRONISATION OFFLINE-FIRST
// ===========================================================================

class OfflineFirstService {
  private isSyncing = false
  private syncInterval: NodeJS.Timeout | null = null
  private retryTimeouts = new Map<string, NodeJS.Timeout>()

  constructor() {
    // D√©marrer auto-sync quand connexion r√©tablie
    connectivityMonitor.addListener((isOnline) => {
      if (isOnline && !this.isSyncing) {
        console.log('üîÑ Connexion r√©tablie - D√©marrage de la synchronisation...')
        this.sync()
      }
    })

    // Enregistrer le Service Worker avec Background Sync
    this.registerBackgroundSync()
  }

  // =========================================================================
  // √âCRITURE OPTIMISTE (PATIENTS)
  // =========================================================================

  async createPatient(data: any): Promise<OfflineWriteResult> {
    const localId = uuidv4()
    const timestamp = new Date().toISOString()
    const isOffline = !connectivityMonitor.isOnline()

    const patientData = {
      id: localId,
      ...data,
      created_at: timestamp,
      updated_at: timestamp,
      version: 1,
      _synced: false,
      _local_id: localId,
    }

    try {
      // 1. √âcriture locale IMM√âDIATE (UI Optimiste)
      await db.patients.add(patientData)
      console.log('‚úÖ Patient sauvegard√© localement:', localId)

      // 2. Ajouter √† l'outbox queue
      await db.addToOutbox('create', 'patient', {
        ...data,
        id: localId,
      }, localId)

      // 3. Sync imm√©diate si online
      if (!isOffline) {
        // Sync en arri√®re-plan (non-bloquant)
        this.sync().catch(err => console.error('Background sync failed:', err))
      }

      return {
        success: true,
        localId,
        data: patientData,
        isOffline,
        willSyncLater: isOffline || true,
      }
    } catch (error: any) {
      console.error('‚ùå Erreur cr√©ation patient offline:', error)
      throw new Error(`Impossible de sauvegarder le patient: ${error.message}`)
    }
  }

  async updatePatient(id: string, data: any): Promise<OfflineWriteResult> {
    const timestamp = new Date().toISOString()
    const isOffline = !connectivityMonitor.isOnline()

    try {
      // R√©cup√©rer la version actuelle
      const existing = await db.patients.get(id)
      if (!existing) {
        throw new Error('Patient introuvable')
      }

      const updatedData = {
        ...existing,
        ...data,
        updated_at: timestamp,
        version: (existing.version || 1) + 1,
        _synced: false,
      }

      // 1. Mise √† jour locale IMM√âDIATE
      await db.patients.put(updatedData)
      console.log('‚úÖ Patient mis √† jour localement:', id)

      // 2. Ajouter √† l'outbox
      await db.addToOutbox('update', 'patient', updatedData, id)

      // 3. Sync si online
      if (!isOffline) {
        this.sync().catch(err => console.error('Background sync failed:', err))
      }

      return {
        success: true,
        localId: id,
        data: updatedData,
        isOffline,
        willSyncLater: isOffline || true,
      }
    } catch (error: any) {
      console.error('‚ùå Erreur mise √† jour patient:', error)
      throw new Error(`Impossible de mettre √† jour le patient: ${error.message}`)
    }
  }

  // =========================================================================
  // √âCRITURE OPTIMISTE (CONSULTATIONS/ENCOUNTERS)
  // =========================================================================

  async createEncounter(data: any): Promise<OfflineWriteResult> {
    const localId = uuidv4()
    const timestamp = new Date().toISOString()
    const isOffline = !connectivityMonitor.isOnline()

    const encounterData = {
      id: localId,
      ...data,
      created_at: timestamp,
      updated_at: timestamp,
      version: 1,
      _synced: false,
      _local_id: localId,
    }

    try {
      // 1. √âcriture locale
      await db.encounters.add(encounterData)
      console.log('‚úÖ Consultation sauvegard√©e localement:', localId)

      // 2. Outbox
      await db.addToOutbox('create', 'encounter', {
        ...data,
        id: localId,
      }, localId)

      // 3. Sync
      if (!isOffline) {
        this.sync().catch(err => console.error('Background sync failed:', err))
      }

      return {
        success: true,
        localId,
        data: encounterData,
        isOffline,
        willSyncLater: isOffline || true,
      }
    } catch (error: any) {
      console.error('‚ùå Erreur cr√©ation consultation:', error)
      throw new Error(`Impossible de sauvegarder la consultation: ${error.message}`)
    }
  }

  // =========================================================================
  // SYNCHRONISATION AVEC RETRY INTELLIGENT
  // =========================================================================

  async sync(): Promise<SyncResult> {
    if (this.isSyncing) {
      console.log('‚è≠Ô∏è  Sync d√©j√† en cours, ignor√©')
      return { success: true, synced: 0, failed: 0, conflicts: 0, errors: [] }
    }

    if (!connectivityMonitor.isOnline()) {
      console.log('üìµ Offline, sync report√©e')
      return { success: false, synced: 0, failed: 0, conflicts: 0, errors: ['Offline'] }
    }

    this.isSyncing = true
    const result: SyncResult = {
      success: true,
      synced: 0,
      failed: 0,
      conflicts: 0,
      errors: [],
    }

    try {
      console.log('üîÑ D√©marrage de la synchronisation...')

      // R√©cup√©rer les op√©rations en attente
      const pendingOps = await db.getPendingOperations()
      console.log(`üì¶ ${pendingOps.length} op√©rations en attente`)

      // Traiter chaque op√©ration
      for (const op of pendingOps) {
        try {
          await this.processOperationWithRetry(op)
          await db.markOperationProcessed(op.id)
          result.synced++
          console.log(`‚úÖ Op√©ration ${op.id} synchronis√©e`)
        } catch (error: any) {
          console.error(`‚ùå √âchec op√©ration ${op.id}:`, error)

          // V√©rifier si c'est une erreur de quota (402)
          if (error.response?.status === 402 || error.status === 402) {
            console.warn('‚ö†Ô∏è Quota d√©pass√© - arr√™t des tentatives')
            await db.markOperationProcessed(op.id)
            
            // Afficher un popup pour upgrader
            const shouldUpgrade = window.confirm(
              "Quota d√©pass√© ! Votre abonnement gratuit est limit√© √† 50 patients. Souhaitez-vous upgrader votre abonnement ?"
            )
            
            if (shouldUpgrade) {
              window.location.href = '/subscription'
            }
            
            result.failed++
            result.errors.push(`Quota d√©pass√©: ${error.response?.data?.detail || error.message}`)
            continue
          }

          // V√©rifier si c'est une erreur de quota (402)
          if (error.response?.status === 402 || error.status === 402) {
            console.warn('‚ö†Ô∏è Quota d√©pass√© - arr√™t des tentatives')
            await db.markOperationProcessed(op.id)
            
            // Afficher un popup pour upgrader
            const shouldUpgrade = window.confirm(
              "Quota d√©pass√© ! Votre abonnement gratuit est limit√© √† 50 patients. Souhaitez-vous upgrader votre abonnement ?"
            )
            
            if (shouldUpgrade) {
              window.location.href = '/subscription'
            }
            
            result.failed++
            result.errors.push(`Quota d√©pass√©: ${error.response?.data?.detail || error.message}`)
            continue
          }

          // V√©rifier si c'est un conflit
          const isConflict = error.status === 409 || error.message.includes('conflit')

          if (isConflict) {
            // Tenter de r√©soudre le conflit
            const resolved = await this.resolveConflict(op, error)
            if (resolved) {
              result.synced++
              result.conflicts++
              await db.markOperationProcessed(op.id)
              console.log(`‚úÖ Conflit ${op.id} r√©solu`)
              continue
            }
          }

          // Incr√©menter les tentatives
          const newAttempts = op.attempts + 1
          await db.incrementOperationAttempts(op.id, error.message)

          // Abandonner apr√®s 10 tentatives
          if (!ExponentialBackoff.shouldRetry(newAttempts)) {
            console.warn(`‚ö†Ô∏è  Op√©ration ${op.id} abandonn√©e apr√®s ${newAttempts} tentatives`)
            await db.markOperationProcessed(op.id) // Marquer comme trait√©e pour l'enlever de la queue
            result.errors.push(`${op.entity} abandonn√© apr√®s ${newAttempts} tentatives`)
          } else {
            // Planifier un retry avec backoff
            this.scheduleRetry(op, newAttempts)
          }

          result.failed++
          result.errors.push(`${op.entity} ${op.operation}: ${error.message}`)
        }
      }

      // Mettre √† jour le timestamp de derni√®re sync
      await db.sync_meta.put({
        key: 'last_sync_time',
        value: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      })

      result.success = result.failed === 0
      console.log(`‚úÖ Sync termin√©e: ${result.synced} r√©ussies, ${result.failed} √©chou√©es, ${result.conflicts} conflits r√©solus`)

    } catch (error: any) {
      console.error('‚ùå Erreur globale de synchronisation:', error)
      result.success = false
      result.errors.push(error.message)
    } finally {
      this.isSyncing = false
    }

    return result
  }

  /**
   * Traite une op√©ration avec retry automatique
   */
  private async processOperationWithRetry(op: OutboxOperation): Promise<void> {
    const { operation, entity, payload, client_id } = op

    // Note: L'idempotency key est g√©r√©e automatiquement par l'API

    switch (entity) {
      case 'patient':
        if (operation === 'create') {
          const response = await patientsService.create(payload)
          // Mettre √† jour l'ID local avec l'ID serveur
          if (client_id && response.id !== client_id) {
            await db.patients.update(client_id, {
              id: response.id,
              _synced: true,
              _local_id: client_id,
            })
            // Mettre √† jour les encounters li√©s
            await db.encounters
              .where('patient_id')
              .equals(client_id)
              .modify({ patient_id: response.id })
          } else {
            await db.patients.update(client_id || response.id, { _synced: true })
          }
        } else if (operation === 'update') {
          await patientsService.update(payload.id, payload)
          await db.patients.update(payload.id, { _synced: true })
        }
        break

      case 'encounter':
        if (operation === 'create') {
          const response = await encountersService.create(payload)
          if (client_id && response.id !== client_id) {
            await db.encounters.update(client_id, {
              id: response.id,
              _synced: true,
              _local_id: client_id,
            })
          } else {
            await db.encounters.update(client_id || response.id, { _synced: true })
          }
        }
        break

      case 'condition':
        if (operation === 'create') {
          await conditionsService.create(payload)
          await db.conditions.update(payload.id, { _synced: true })
        }
        break

      case 'medication_request':
        if (operation === 'create') {
          await medicationsService.create(payload)
          await db.medication_requests.update(payload.id, { _synced: true })
        }
        break

      case 'procedure':
        if (operation === 'create') {
          await proceduresService.create(payload)
          await db.procedures.update(payload.id, { _synced: true })
        }
        break

      default:
        throw new Error(`Type d'entit√© inconnu: ${entity}`)
    }
  }

  /**
   * Planifie un retry avec exponential backoff
   */
  private scheduleRetry(op: OutboxOperation, attempt: number) {
    // Annuler le timeout existant s'il y en a un
    const existingTimeout = this.retryTimeouts.get(op.id)
    if (existingTimeout) {
      clearTimeout(existingTimeout)
    }

    const delay = ExponentialBackoff.calculateDelay(attempt)

    const timeoutId = setTimeout(() => {
      console.log(`üîÑ Retry op√©ration ${op.id} (tentative ${attempt + 1})`)
      this.sync().catch(err => console.error('Retry sync failed:', err))
      this.retryTimeouts.delete(op.id)
    }, delay)

    this.retryTimeouts.set(op.id, timeoutId)
  }

  /**
   * R√©sout un conflit automatiquement
   */
  private async resolveConflict(op: OutboxOperation, error: any): Promise<boolean> {
    try {
      console.log(`‚ö†Ô∏è  Conflit d√©tect√© pour ${op.entity} ${op.id}`)

      // R√©cup√©rer la version serveur
      let serverData: any
      switch (op.entity) {
        case 'patient':
          serverData = await patientsService.get(op.payload.id)
          break
        case 'encounter':
          serverData = await encountersService.get(op.payload.id)
          break
        default:
          return false
      }

      // Appliquer la strat√©gie Last-Write-Wins
      const resolution = ConflictResolver.resolveLastWriteWins(op.payload, serverData)

      // Mettre √† jour la base locale avec la version gagnante
      if (resolution.resolvedData) {
        const table = op.entity === 'patient' ? db.patients : db.encounters
        await table.put({
          ...resolution.resolvedData,
          _synced: true,
        })

        // Si la version locale a gagn√©, r√©essayer l'upload
        if (resolution.resolvedData === op.payload) {
          await this.processOperationWithRetry(op)
        }

        return true
      }

      return false
    } catch (err: any) {
      console.error('Erreur r√©solution conflit:', err.message || err)
      return false
    }
  }

  /**
   * Enregistre le Service Worker avec Background Sync
   */
  private async registerBackgroundSync() {
    if ('serviceWorker' in navigator && 'sync' in ServiceWorkerRegistration.prototype) {
      try {
        const registration = await navigator.serviceWorker.ready

        // √âcouter les messages du Service Worker
        navigator.serviceWorker.addEventListener('message', (event) => {
          this.handleServiceWorkerMessage(event.data)
        })

        // Enregistrer un tag de sync
        await (registration as any).sync.register('sync-outbox')
        console.log('‚úÖ Background Sync enregistr√©')
      } catch (error) {
        console.warn('‚ö†Ô∏è  Background Sync non support√©:', error)
      }
    }
  }

  /**
   * G√®re les messages re√ßus du Service Worker
   */
  private handleServiceWorkerMessage(data: any) {
    switch (data.type) {
      case 'SYNC_STARTED':
        console.log(`üîÑ Background Sync d√©marr√© (${data.count} op√©rations)`)
        break

      case 'SYNC_SUCCESS':
        console.log(`‚úÖ Background Sync r√©ussi (${data.count} op√©rations)`)
        // D√©clencher un sync normal pour mettre √† jour l'UI
        this.sync()
        break

      case 'SYNC_FAILED':
        console.error('‚ùå Background Sync √©chou√©:', data.error)
        break
    }
  }

  /**
   * D√©marre la synchronisation automatique
   */
  startAutoSync(intervalMs: number = 120000) {
    if (this.syncInterval) {
      clearInterval(this.syncInterval)
    }

    // Sync imm√©diate
    this.sync()

    // Puis sync p√©riodique
    this.syncInterval = setInterval(() => {
      if (connectivityMonitor.isOnline() && !this.isSyncing) {
        this.sync()
      }
    }, intervalMs)

    console.log(`‚úÖ Auto-sync d√©marr√© (intervalle: ${intervalMs / 1000}s)`)
  }

  /**
   * Arr√™te la synchronisation automatique
   */
  stopAutoSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval)
      this.syncInterval = null
    }

    // Annuler tous les retries
    this.retryTimeouts.forEach(timeout => clearTimeout(timeout))
    this.retryTimeouts.clear()

    console.log('‚èπÔ∏è  Auto-sync arr√™t√©')
  }

  /**
   * Force une synchronisation imm√©diate
   */
  async forceSync(): Promise<SyncResult> {
    return this.sync()
  }

  /**
   * Obtient le nombre d'op√©rations en attente
   */
  async getPendingCount(): Promise<number> {
    return db.outbox.where('processed').equals(0).count()
  }
}

// ===========================================================================
// INSTANCE GLOBALE
// ===========================================================================

export const offlineFirst = new OfflineFirstService()

// D√©marrer l'auto-sync au chargement
if (typeof window !== 'undefined') {
  // Attendre que l'utilisateur soit connect√©
  setTimeout(() => {
    offlineFirst.startAutoSync(120000) // Toutes les 2 minutes
  }, 5000) // D√©lai de 5s pour laisser l'app se charger
}
